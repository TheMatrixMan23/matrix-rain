<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kick Drum Visualizer</title>
    <style>
        body {
            margin: 0;
            overflow: hidden; /* Prevent scrollbars */
            background-color: black;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh; /* Full viewport height */
            font-family: sans-serif;
        }

        canvas {
            position: absolute; /* Important for centering */
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            cursor: pointer; /* Change cursor to pointer on hover */
        }
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            z-index: 10; /* Ensure controls are above the canvas */

        }
         #thresholdInput, #minFrequencyInput, #maxFrequencyInput{
            margin-bottom: 5px;
        }


    </style>
</head>
<body>

<div id="controls">
    Threshold: <input type="number" id="thresholdInput" value="0.15" step="0.01" min="0" max="1"><br/>
    Min Freq: <input type="number" id="minFrequencyInput" value="20" step="1" min="0" max="20000"><br/>
    Max Freq: <input type="number" id="maxFrequencyInput" value="150" step="1" min="0" max="20000"><br/>
</div>

<canvas id="myCanvas"></canvas>

<script>
    const thresholdInput = document.getElementById('thresholdInput');
    const minFrequencyInput = document.getElementById('minFrequencyInput');
    const maxFrequencyInput = document.getElementById('maxFrequencyInput');
    const canvas = document.getElementById('myCanvas');
    const ctx = canvas.getContext('2d');

    let audioContext;
    let analyser;
    let source;
    let audioBuffer;
    let kickDetected = false;
    let animationId;
    let isPlaying = false; // Track whether audio is playing

    // **1. File Path (CHANGE THIS!)**
    const audioFilePath = "audio/LL.m4a"; //  Replace with your actual path

    // Resize canvas
    function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        drawInitialCircle(); // Redraw the circle on resize
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);


    // Draw initial circle
    function drawInitialCircle() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.beginPath();
        ctx.arc(canvas.width / 2, canvas.height / 2, 50, 0, 2 * Math.PI);
        ctx.fillStyle = 'white';
        ctx.fill();
        ctx.closePath();
    }


    // Draw (and fade) the circle on kick
      function drawCircle() {
        ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear previous circle
        ctx.beginPath();
        ctx.arc(canvas.width / 2, canvas.height / 2, 50, 0, 2 * Math.PI);
        ctx.fillStyle = 'white';
        ctx.fill();
        ctx.closePath();

       //Fade out animation.
        function fadeOut() {
             if (ctx.globalAlpha > 0) {
                ctx.globalAlpha -= 0.05; // Adjust for speed of fade
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.beginPath();
                ctx.arc(canvas.width / 2, canvas.height / 2, 50, 0, 2 * Math.PI);
                ctx.fillStyle = 'white';
                ctx.fill();
                ctx.closePath();
                requestAnimationFrame(fadeOut);
            }
            else{
                ctx.globalAlpha = 1.0;
                drawInitialCircle(); //Redraw.
            }

        }
        fadeOut();
    }

    // Audio analysis
    function analyzeAudio() {
      if (!isPlaying) return; // Don't analyze if not playing

        const bufferLength = analyser.frequencyBinCount;
        const dataArray = new Uint8Array(bufferLength);

        const checkKick = () => {
            if (!isPlaying) {  // Important check within the loop
                return;
            }
            analyser.getByteFrequencyData(dataArray);
            const threshold = parseFloat(thresholdInput.value);
            const minFrequency = parseInt(minFrequencyInput.value);
            const maxFrequency = parseInt(maxFrequencyInput.value);
            const frequencyBinWidth = audioContext.sampleRate / analyser.fftSize;
            const minIndex = Math.floor(minFrequency / frequencyBinWidth);
            const maxIndex = Math.floor(maxFrequency / frequencyBinWidth);

            let sum = 0;
            for (let i = minIndex; i <= maxIndex; i++) {
                sum += dataArray[i];
            }
            const average = sum / (maxIndex - minIndex + 1);
            const normalizedAverage = average / 255;

            if (normalizedAverage > threshold && !kickDetected) {
                drawCircle();
                kickDetected = true;
            } else if (normalizedAverage <= threshold) {
                kickDetected = false;
            }

            animationId = requestAnimationFrame(checkKick);
        };
        checkKick();
    }

    // Load and Play Audio (triggered by click)
    async function loadAndPlayAudio() {
        try {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }

            const response = await fetch(audioFilePath);
            if (!response.ok) {
                throw new Error(`HTTP error! Status: ${response.status}`);
            }
            const arrayBuffer = await response.arrayBuffer();

            audioContext.decodeAudioData(arrayBuffer, (buffer) => {
                audioBuffer = buffer;
                source = audioContext.createBufferSource();
                source.buffer = audioBuffer;
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 2048;
                source.connect(analyser);
                analyser.connect(audioContext.destination);


              // Start playing and analyzing, ONLY once things are set up.
              if (audioContext.state === 'suspended') {
                    audioContext.resume().then(() => {
                        source.start();
                        isPlaying = true; // Set playing flag
                        analyzeAudio();
                    });
                } else {
                    source.start();
                    isPlaying = true; //Set.
                    analyzeAudio();
                }

                source.onended = () => {
                    isPlaying = false; // Reset playing flag
                    cancelAnimationFrame(animationId);
                    kickDetected = false;
                    drawInitialCircle(); //Redraw.
                     if (source) {
                        source.disconnect();
                        source = null;
                    }
                };

            }, (error) => {
                console.error("Error decoding audio data:", error);
                alert("Error decoding audio data. Check the console for details.");
            });

        } catch (error) {
            console.error("Error loading audio:", error);
            alert("Error loading audio. Check the console for details.");
        }
    }
    //Click Event Handler

    canvas.addEventListener('click', () => {
      if (!isPlaying){
        if (!audioBuffer) { // First click: load and play
            loadAndPlayAudio();
        } else { // Subsequent clicks: resume if suspended
             if (audioContext.state === 'suspended') {
                audioContext.resume().then(()=> {
                    source.start();
                    isPlaying = true;
                    analyzeAudio();
                });

            }
             else{
                  source.start(); // Start audio
                  isPlaying = true; // Set
                  analyzeAudio(); // Begin analysis
             }
        }
      }
      else{
        source.stop();
        isPlaying = false;
        cancelAnimationFrame(animationId);
        kickDetected = false;
        drawInitialCircle();
      }
    });


    // Initial drawing
    drawInitialCircle();

</script>

</body>
</html>
